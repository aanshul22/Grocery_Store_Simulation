"""Assignment 1 - Events (Task 2)

=== CSC148 Fall 2019 ===
Department of Computer Science,
University of Toronto

=== Module description ===
This module contains all of the classes necessary to model the different
kinds of events in the simulation.

Author: Anshul Agrawal
"""
from __future__ import annotations
from typing import List, TextIO
from store import Customer, Item


class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are greater than those with newer
    timestamps.

    This class is abstract; subclasses must implement do().

    YOU SHOULD NOT CHANGE THIS CLASS!

    === Attributes ===
    timestamp: A timestamp for this event.
    """
    timestamp: int

    def __init__(self, timestamp: int) -> None:
        """Initialize an Event with a given timestamp.

        Precondition: timestamp must be a non-negative integer.

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    def __eq__(self, other: Event) -> bool:
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other: Event) -> bool:
        """Return True iff this Event is not equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other: Event) -> bool:
        """Return True iff this Event is less than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other: Event) -> bool:
        """Return True iff this Event is less than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other: Event) -> bool:
        """Return True iff this Event is greater than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other: Event) -> bool:
        """Return True iff this Event is greater than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store: "GroceryStore") -> List[Event]:
        """Return a list of events generated by performing this event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).
        """
        raise NotImplementedError('Implemented in a subclass')


class CustomerArrival(Event):
    """A customer arrives at the checkout area ready to check out.

    === Attributes ===
    customer: The arriving customer
    """
    customer: Customer

    def __init__(self, timestamp: int, c: Customer) -> None:
        """Initialize a CustomerArrival event with <timestamp> and customer <c>.
        """
        Event.__init__(self, timestamp)
        self.customer = c

    def do(self, store: "GroceryStore") -> List[Event]:
        """Assigns the arriving customer to a line in the <store>.
        """
        line_number = store.enter_line(self.customer)
        self.customer.arrival_time = self.timestamp
        if line_number == -1:
            return [CustomerArrival(self.timestamp + 1, self.customer)]
        if store.line_is_ready(line_number):
            return [CheckoutStarted(self.timestamp, line_number)]
        else:
            return []

    def __str__(self) -> str:
        """ Returns the string Representation of the object
        """
        return self.customer.name + ' arrives at ' + str(self.timestamp)


class CheckoutStarted(Event):
    """A customer starts the checkout process.

    Once the checkout process starts, the only way for the customer to leave
    the line is for a CheckoutCompleted event to occur.

    === Attributes ===
    line_number: The number of the checkout line.
    """
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CheckoutStarted event with <timestamp> and
        <line_number>.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def do(self, store: "GroceryStore") -> List[Event]:
        """Starts the checkout for the next customer in line_number.
        """
        billing_time = store.start_checkout(self.line_number)
        return [CheckoutCompleted(self.timestamp + billing_time,
                                  self.line_number,
                                  store.get_first_in_line(self.line_number))]

    def __str__(self) -> str:
        """ Returns the string Representation of the object
        """
        return 'Checkout started at ' + str(self.timestamp) + \
               ' on line ' + str(self.line_number)


class CheckoutCompleted(Event):
    """A customer finishes the checkout process.

    A CheckoutCompleted event might occur after a line closes.

    === Attributes ===
    line_number: The number of the checkout line.
    customer: The finishing customer.
    """
    line_number: int
    customer: Customer

    def __init__(self, timestamp: int, line_number: int, c: Customer) -> None:
        """Initialize a CheckoutCompleted event with <timestamp>, <line_number>,
        and customer <c>.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number
        self.customer = c

    def do(self, store: "GroceryStore") -> List[Event]:
        """Finishs the checkout for the customer in line_number.
        """
        are_more = store.complete_checkout(self.line_number)
        if are_more:
            return [CheckoutStarted(self.timestamp, self.line_number)]
        else:
            return []

    def __str__(self) -> str:
        """ Returns the string Representation of the object
        """
        return self.customer.name + ' completes checkout at ' + \
               str(self.timestamp) + ' line ' + str(self.line_number)


class CloseLine(Event):
    """A CheckoutLine gets closed.

    === Attributes ===
    line_number: The number of the checkout line.
    """
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CloseLine event with <timestamp> and <line_number>.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def do(self, store: "GroceryStore") -> List[Event]:
        """Closes the line line_number and returns the events new customer.
        """
        remaining_customers = store.close_line(self.line_number)[::-1]
        new_events = []
        for customer in remaining_customers:
            new_events.append(CustomerArrival(self.timestamp, customer))
            self.timestamp += 1
        return new_events

    def __str__(self) -> str:
        """ Returns the string Representation of the object
        """
        return 'Line ' + str(self.line_number) + \
               ' closed at ' + str(self.timestamp)


def create_event_list(event_file: TextIO) -> List[Event]:
    """Return a list of Events based on raw list of events in <event_file>.

    Precondition: <event_file> is in the format specified by the assignment
    handout.
    """
    file = [event.strip('\n').split() for event in event_file]
    events = []
    for line in file:
        if line[1] == 'Arrive':
            time = int(line[0])
            customer_name = line[2]
            items = []
            i = 3
            while i < len(line):
                items.append(Item(line[i], int(line[i+1])))
                i += 2
            events.append(CustomerArrival(time, Customer(customer_name, items)))
        else:
            time = int(line[0])
            line_index = int(line[2])
            events.append(CloseLine(time, line_index))
    return events


if __name__ == '__main__':
    import doctest
    doctest.testmod()
    import python_ta
    python_ta.check_all(config={
        'allowed-import-modules': ['__future__', 'typing', 'store',
                                   'python_ta', 'doctest']})
